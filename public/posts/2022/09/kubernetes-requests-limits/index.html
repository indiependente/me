<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes Requests & Limits | Francesco Farina</title>
<meta name=keywords content="kubernetes,requests,limits,cpu,memory,pods,containers,performance,cfs,cgroups"><meta name=description content="This document is the result of research on the topic of CPU/Memory Limits and Requests for Kubernetes, to provide engineers with a better understanding of how such configuration work and can affect the execution and performance of services.

Requests and Limits are the mechanisms k8s uses to control the utilisation of resources such as CPU and memory.
Requests are what the container is guaranteed to get. If a container requests a resource, the kube-scheduler will only schedule it on a node that can give it that resource."><meta name=author content><link rel=canonical href=https://indiependente.dev/posts/2022/09/kubernetes-requests-limits/><link crossorigin=anonymous href=https://indiependente.dev/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://indiependente.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://indiependente.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://indiependente.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://indiependente.dev/apple-touch-icon.png><link rel=mask-icon href=https://indiependente.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://indiependente.dev/posts/2022/09/kubernetes-requests-limits/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://indiependente.dev/posts/2022/09/kubernetes-requests-limits/"><meta property="og:site_name" content="Francesco Farina"><meta property="og:title" content="Kubernetes Requests & Limits"><meta property="og:description" content="This document is the result of research on the topic of CPU/Memory Limits and Requests for Kubernetes, to provide engineers with a better understanding of how such configuration work and can affect the execution and performance of services.
Requests and Limits are the mechanisms k8s uses to control the utilisation of resources such as CPU and memory.
Requests are what the container is guaranteed to get. If a container requests a resource, the kube-scheduler will only schedule it on a node that can give it that resource."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-15T13:39:00+00:00"><meta property="article:modified_time" content="2022-09-15T13:39:00+00:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Requests"><meta property="article:tag" content="Limits"><meta property="article:tag" content="Cpu"><meta property="article:tag" content="Memory"><meta property="article:tag" content="Pods"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes Requests & Limits"><meta name=twitter:description content="This document is the result of research on the topic of CPU/Memory Limits and Requests for Kubernetes, to provide engineers with a better understanding of how such configuration work and can affect the execution and performance of services.

Requests and Limits are the mechanisms k8s uses to control the utilisation of resources such as CPU and memory.
Requests are what the container is guaranteed to get. If a container requests a resource, the kube-scheduler will only schedule it on a node that can give it that resource."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://indiependente.dev/posts/"},{"@type":"ListItem","position":2,"name":"Kubernetes Requests \u0026 Limits","item":"https://indiependente.dev/posts/2022/09/kubernetes-requests-limits/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes Requests \u0026 Limits","name":"Kubernetes Requests \u0026 Limits","description":"This document is the result of research on the topic of CPU/Memory Limits and Requests for Kubernetes, to provide engineers with a better understanding of how such configuration work and can affect the execution and performance of services.\nRequests and Limits are the mechanisms k8s uses to control the utilisation of resources such as CPU and memory.\nRequests are what the container is guaranteed to get. If a container requests a resource, the kube-scheduler will only schedule it on a node that can give it that resource.\n","keywords":["kubernetes","requests","limits","cpu","memory","pods","containers","performance","cfs","cgroups"],"articleBody":"This document is the result of research on the topic of CPU/Memory Limits and Requests for Kubernetes, to provide engineers with a better understanding of how such configuration work and can affect the execution and performance of services.\nRequests and Limits are the mechanisms k8s uses to control the utilisation of resources such as CPU and memory.\nRequests are what the container is guaranteed to get. If a container requests a resource, the kube-scheduler will only schedule it on a node that can give it that resource.\nLimits, on the other hand, enforce rules. They make sure a container never goes above a value. The kubelet only allows the container to go up to the limit and then it’s restricted.\nLet’s take a look at an example limits and requests configuration.\ncontainers: - name: container1 image: busybox resources: null requests: cpu: 200m memory: 32Mi limits: cpu: 250m memory: 64Mi The Kubernetes scheduler uses the values of CPU and memory to figure out where to run the pods.\nEach container in the pod can set its requests and limits, and these are all additive.\nIn an ideal world, pods should be continuously using exactly the amount of resources requested. But in the real world resource usage is never regular or predictable, that’s why we can consider a 25% margin up and down the request value as a good situation.If the usage is much lower than the request, we are wasting money. If it is higher, we are risking performance issues in the node.\nIt is important to note that the value represents the relative share of CPU time a container will receive when there is contention for CPU resources. It does not represent the actual CPU time each container will receive.\nCPU CPU resources are defined in millicores, if a container needs two full cores to run the value needed will be 2000m.\nOne thing to be aware of is that if the value is larger than the core count of the biggest cluster node, the pod will never be scheduled. This also applies to memory.\nSo unless the app is specifically designed to take advantage of multiple cores, it’s usually a best practice to keep the CPU request at one or below and then run more replicas to scale it out.\nCPU is considered a compressible resource, if the app starts hitting the CPU limits, Kubernetes will start to throttle the container: this means the CPU will be artificially restricted giving the app potentially worse performance. However, it won’t be terminated or evicted.\nMemory Memory resources are defined in bytes. Typically it’s given a value in mebibyte, but it can be configured with anything from bytes to petabytes.\nUnlike the CPU, memory is not compressible. Because there’s no way to throttle memory usage, if a container goes above the memory limit, it will be terminated.\nCPU Limits and Quotas CPU Limit is implemented using CFS bandwidth controller (a subsystem/extension of CFS scheduler), which uses values specified in cpu.cfs_period_us and cpu.cfs_quota_us (us = μ, microseconds) to control how much time is available to each control group.\ncpu.cfs_period_us: length of the accounting period, also in microseconds. This is configured to 100,000 in Kubernetes.\ncpu.cfs_quota_us: the amount of CPU time (in microseconds) available to the group during each accounting period. This value is taken from the limits.cpu.\n1 vCPU == 1000m == 100,000us 0.5vCPU == 500m == 50,000us Quota calculation Considering the definitions above, the quota of CPU time dedicated to a process is calculated as follows:\nquota_us = limits.cpu / requests.cpu * 100000us\nLet’s try that on an example configuration:\nweb_app: resources: requests.cpu: 1000m quota_us = 1000m / 1000m * 100000us = 100000us = 100ms\nAssuming the service takes 200ms to respond and there is no contention, it will be guaranteed the 200ms of uninterrupted CPU time, which equals two consecutive quota slots.\nLet’s consider a different configuration for the same service but with limits involved:\nweb_app: resources: requests.cpu: 1000m limits.cpu: 500m quota_us = 500m / 1000m * 100000us = 50000us = 50ms\nThe service only has a quota of 50ms every period (100.000µs): this means that to fulfil a single request that takes 200ms it will have to use 4 quota slots, interleaved with throttled slots.\nThe same request now takes 350ms to respond!\nTo avoid such situations, Kubernetes will throw an error and will not run the container when limits.cpu \u003c requests.cpu\nThis might seem an obvious result of the above condition but the opposite doesn’t necessarily mean that the service will never throttle.\nThrottling on low CPU usage Imagine a pod with a CPU limit of 100m, which is equivalent to 1/10 vCPU.\nThe pod does nothing for 10 minutes, then uses the CPU nonstop for 200ms. The usage during the burst is equivalent to 2/10 vCPU, hence the pod is over its limit and will be throttled.\nOn the other hand, the average CPU usage will be incredibly low. The burst is so tiny (200 milliseconds) that it won’t show up in any graphs.\nRemoving CPU Limits As many articles state, there have been positive experiences in the Kubernetes community of running containers without CPU Limits (Reference section: no. 7 and 8).\nBut, even though it may seem like an easy trick that achieves lower latencies and better CPU usage, it’s not always the case nor it’s that easy, for example:\nin Kubernetes: Make your services faster by removing CPU limits, the author explains they had to isolate unbounded services to dedicated nodes, to mitigate them from using too many resources in a node shared with bounded services; in Did Kubernetes Make My p95s Worse? - Jian Cheung \u0026 Stephen Chan, Airbnb, the speakers show how in the early days of AirBnB they decided to not set CPU Limits because they thought it would hurt performance, but that turned out to be worse than expected, creating a noisy neighbours effect, where a small number of services ends up dominating the CPU time; in For the love of God, stop using CPU limits on Kubernetes, the author suggests setting a requests quota and removing any CPU limit, and even if this can work for a majority of scenarios, it’s not a golden rule because as described above can lead to one or more services starve the rest. Namespace resource allocation People can forget to set the requests value or someone might intentionally set their limits very high in order to obtain more than a fair amount of resources.\nTo prevent these scenarios, Resource Quotas and Limit Ranges can be assigned.\nFor example, a very strict resource quota can be set on the development namespace while no quota is specified on the production one.\nA Limit Range, instead, enforces itself on individual containers. This can help prevent the creation of tiny or massive containers inside the namespace. It’s important to note that if the default section is not set and the minimum or maximum section is set, then the minimum or the maximum will become the default for each container.\nKey takeaways Throttling in very low numbers is physiological to services running in a distributed system with shared resources Monitor resource usage and requests/limits thresholds to fine-tune each service configuration Removing CPU Limits can bring benefits but consider the nature of each service running in the cluster before changing that configuration CPU bound vs IO bound applications, bursting vs constant request rates Benchmarking each service under load gives a good idea of the resource usage and how to configure it Appendix 1. How pod specs are propagated Pod spec is registered in etcd through the kube-apiserver kube-scheduler fetches newly registered pods from etcd and assigns a node to each pod referring to resource requests kubelet fetches assigned pod spec in every sync period and calculates the differences between running containers and pod spec kubelet calls CreateContainer operation on the CRI Runtime, after converting CPU cores into periods CRI Runtime executes OCI Runtime binary to create a container with OCI Spec JSON OCI Runtime creates/updates/deletes cgroups accordingly 2. QoS Classes When Kubernetes creates a Pod, it assigns one of the following QoS classes depending on the condition\nQoS Class Condition Priority (lower is better) Guaranteed Limits and optionally requests (not equal to 0) are set for all resources across all containers and they are equal 1 Burstable Requests and optionally limits are set (not equal to 0) for one or more resources across one or more containers, and they are not equal 2 Best Effort Requests and limits are not set for all of the resources, across all containers 3 References Resource Management for Pods and Containers Assign CPU Resources to Containers and Pods Assign Memory Resources to Containers and Pods Container Runtime Interface (CRI) Configure Quality of Service for Pods CFS Scheduler on kernel.org For the love of God, stop using CPU limits on Kubernetes Kubernetes: Make your services faster by removing CPU limits Kubernetes failure stories HN conversation about removing CPU Limits CPU Throttling - Unthrottled: Fixing CPU limits in the Cloud Throttling: New Developments in Application Performance with CPU Limits - Dave Chiluk, Indeed Resource Requests and Limits Under the Hood: The Journey of a Pod Spec - Kohei Ota \u0026 Kaslin Fields 10 More Weird Ways to Blow Up Your Kubernetes - Jian Cheung \u0026 Joseph Kim, Airbnb Did Kubernetes Make My p95s Worse? - Jian Cheung \u0026 Stephen Chan, Airbnb ","wordCount":"1564","inLanguage":"en","datePublished":"2022-09-15T13:39:00Z","dateModified":"2022-09-15T13:39:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://indiependente.dev/posts/2022/09/kubernetes-requests-limits/"},"publisher":{"@type":"Organization","name":"Francesco Farina","logo":{"@type":"ImageObject","url":"https://indiependente.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://indiependente.dev/ accesskey=h title="Francesco Farina (Alt + H)">Francesco Farina</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://indiependente.dev/it/ title=It aria-label=It>It</a></li></ul></div></div><ul id=menu><li><a href=https://indiependente.dev/about title=About><span>About</span></a></li><li><a href=https://indiependente.dev/posts title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://indiependente.dev/>Home</a>&nbsp;»&nbsp;<a href=https://indiependente.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kubernetes Requests & Limits</h1><div class=post-meta><span title='2022-09-15 13:39:00 +0000 UTC'>September 15, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1564 words</div></header><div class=post-content><p><em>This document is the result of research on the topic of CPU/Memory Limits and Requests for Kubernetes, to provide engineers with a better understanding of how such configuration work and can affect the execution and performance of services.</em></p><hr><p>Requests and Limits are the mechanisms k8s uses to control the utilisation of resources such as CPU and memory.</p><p>Requests are what the container is <strong>guaranteed</strong> to get. If a container requests a resource, the <em>kube-scheduler</em> will only schedule it on a node that can give it that resource.</p><p>Limits, on the other hand, <strong>enforce rules</strong>. They make sure a container never goes above a value. The <em>kubelet</em> only allows the container to go up to the limit and then it’s restricted.</p><p>Let’s take a look at an example limits and requests configuration.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: container1
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>image</span>: busybox
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>resources</span>: <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>requests</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>cpu</span>: 200m
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>memory</span>: 32Mi
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>limits</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>cpu</span>: 250m
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>memory</span>: 64Mi
</span></span></code></pre></div><p>The Kubernetes scheduler uses the values of CPU and memory to figure out where to run the pods.</p><p>Each container in the pod can set its requests and limits, and these are all additive.</p><p>In an ideal world, pods should be continuously using exactly the amount of resources requested. But in the real world resource usage is never regular or predictable, that&rsquo;s why we can consider a 25% margin up and down the request value as a good situation.If the usage is much lower than the request, we are wasting money. If it is higher, we are risking performance issues in the node.</p><p><em>It is important to note that the value represents the <strong>relative share</strong> of CPU time a container will receive when there is <strong>contention</strong> for CPU resources. It does not represent the actual CPU time each container will receive.</em></p><hr><h2 id=cpu>CPU<a hidden class=anchor aria-hidden=true href=#cpu>#</a></h2><p>CPU resources are defined in <em>millicores,</em> if a container needs two full cores to run the value needed will be 2000m.</p><p>One thing to be aware of is that if the value is larger than the core count of the biggest cluster node, the pod will never be scheduled. This also applies to memory.</p><p>So unless the app is specifically designed to take advantage of multiple cores, it’s usually a best practice to keep the CPU request at one or below and then run more replicas to scale it out.</p><p>CPU is considered a compressible resource, if the app starts hitting the CPU limits, Kubernetes will start to throttle the container: this means the CPU will be artificially restricted giving the app potentially worse performance. However, it won’t be terminated or evicted.</p><h2 id=memory>Memory<a hidden class=anchor aria-hidden=true href=#memory>#</a></h2><p>Memory resources are defined in bytes. Typically it’s given a value in mebibyte, but it can be configured with anything from bytes to petabytes.</p><p>Unlike the CPU, memory is not compressible. Because there’s no way to throttle memory usage, if a container goes above the memory limit, it will be terminated.</p><h2 id=cpu-limits-and-quotas>CPU Limits and Quotas<a hidden class=anchor aria-hidden=true href=#cpu-limits-and-quotas>#</a></h2><p>CPU Limit is implemented using CFS bandwidth controller (a subsystem/extension of CFS scheduler), which uses values specified in cpu.cfs_period_us and cpu.cfs_quota_us (us = μ, microseconds) to control how much time is available to each control group.</p><p>cpu.cfs_period_us: length of the accounting period, also in microseconds. This is configured to <strong>100,000</strong> in Kubernetes.</p><p>cpu.cfs_quota_us: the amount of CPU time (in microseconds) available to the group during each accounting period. This value is taken from the limits.cpu.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>1 vCPU == 1000m == 100,000us
</span></span><span style=display:flex><span>0.5vCPU == 500m == 50,000us
</span></span></code></pre></div><h3 id=quota-calculation>Quota calculation<a hidden class=anchor aria-hidden=true href=#quota-calculation>#</a></h3><p>Considering the definitions above, the quota of CPU time dedicated to a process is calculated as follows:</p><p><code>quota_us = limits.cpu / requests.cpu * 100000us</code></p><p>Let’s try that on an example configuration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>web_app</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>resources</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>requests.cpu</span>: 1000m
</span></span></code></pre></div><p><code>quota_us = 1000m / 1000m * 100000us = 100000us = 100ms</code></p><p>Assuming the service takes 200ms to respond and there is no contention, it will be guaranteed the 200ms of uninterrupted CPU time, which equals two consecutive quota slots.</p><p>Let’s consider a different configuration for the same service but with limits involved:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>web_app</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>resources</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>requests.cpu</span>: 1000m
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>limits.cpu</span>: 500m
</span></span></code></pre></div><p><code>quota_us = 500m / 1000m * 100000us = 50000us = 50ms</code></p><p>The service only has a quota of 50ms every period (100.000µs): this means that to fulfil a single request that takes 200ms it will have to use 4 quota slots, interleaved with <strong>throttled</strong> slots.</p><p>The same request now takes <em><strong>350ms</strong></em> to respond!</p><p><img alt="CPU quota allocation" loading=lazy src=https://res.cloudinary.com/indiependente/image/upload/v1663248072/indiependente.dev/k8srequestslimits/cpuquota.png></p><p><em>To avoid such situations, Kubernetes will throw an error and will not run the container when limits.cpu &lt; requests.cpu</em></p><p>This might seem an obvious result of the above condition but the opposite doesn’t necessarily mean that the service will never throttle.</p><h3 id=throttling-on-low-cpu-usage>Throttling on low CPU usage<a hidden class=anchor aria-hidden=true href=#throttling-on-low-cpu-usage>#</a></h3><p>Imagine a pod with a CPU limit of 100m, which is equivalent to 1/10 vCPU.</p><p>The pod does nothing for 10 minutes, then uses the CPU nonstop for 200ms. The usage during the burst is equivalent to 2/10 vCPU, hence the pod is over its limit and will be throttled.</p><p>On the other hand, the average CPU usage will be incredibly low. The burst is so tiny (200 milliseconds) that it won&rsquo;t show up in any graphs.</p><h2 id=removing-cpu-limits>Removing CPU Limits<a hidden class=anchor aria-hidden=true href=#removing-cpu-limits>#</a></h2><p>As many articles state, there have been positive experiences in the Kubernetes community of running containers without CPU Limits (Reference section: no. 7 and 8).</p><p>But, even though it may seem like an easy trick that achieves lower latencies and better CPU usage, it’s not always the case nor it’s that easy, for example:</p><ul><li>in <a href=https://erickhun.com/posts/kubernetes-faster-services-no-cpu-limits/>Kubernetes: Make your services faster by removing CPU limits</a>, the author explains they had to isolate <em>unbounded</em> services to dedicated nodes, to mitigate them from using too many resources in a node shared with <em>bounded</em> services;</li><li>in <a href="https://www.youtube.com/watch?v=QXApVwRBeys">Did Kubernetes Make My p95s Worse? - Jian Cheung & Stephen Chan, Airbnb</a>, the speakers show how in the early days of AirBnB they decided to not set CPU Limits because they thought it would hurt performance, but that turned out to be worse than expected, creating a <em>noisy neighbours</em> effect, where a small number of services ends up dominating the CPU time;</li><li>in <a href=https://home.robusta.dev/blog/stop-using-cpu-limits/>For the love of God, stop using CPU limits on Kubernetes</a>, the author suggests setting a requests quota and removing any CPU limit, and even if this can work for a majority of scenarios, it’s not a golden rule because as described above can lead to one or more services starve the rest.</li></ul><h2 id=namespace-resource-allocation>Namespace resource allocation<a hidden class=anchor aria-hidden=true href=#namespace-resource-allocation>#</a></h2><p>People can forget to set the requests value or someone might intentionally set their limits very high in order to obtain more than a fair amount of resources.</p><p>To prevent these scenarios, <strong>Resource Quotas</strong> and <strong>Limit Ranges</strong> can be assigned.</p><p>For example, a very strict resource quota can be set on the development namespace while no quota is specified on the production one.</p><p>A Limit Range, instead, enforces itself on individual containers. This can help prevent the creation of tiny or massive containers inside the namespace. It’s important to note that if the default section is not set and the minimum or maximum section is set, then the minimum or the maximum will become the default for each container.</p><h2 id=key-takeaways>Key takeaways<a hidden class=anchor aria-hidden=true href=#key-takeaways>#</a></h2><ul><li>Throttling in very low numbers is <em>physiological</em> to services running in a distributed system with shared resources</li><li><strong>Monitor</strong> resource usage and requests/limits thresholds to fine-tune each service configuration</li><li>Removing CPU Limits can bring benefits but consider the <strong>nature</strong> of each service running in the cluster before changing that configuration<ul><li>CPU bound vs IO bound applications, bursting vs constant request rates</li><li><strong>Benchmarking</strong> each service under load gives a good idea of the resource usage and how to configure it</li></ul></li></ul><h2 id=appendix>Appendix<a hidden class=anchor aria-hidden=true href=#appendix>#</a></h2><h3 id=1-how-pod-specs-are-propagated>1. How pod specs are propagated<a hidden class=anchor aria-hidden=true href=#1-how-pod-specs-are-propagated>#</a></h3><p><img alt="Pod spec propagation from k8s control plane to cgroups" loading=lazy src=https://res.cloudinary.com/indiependente/image/upload/v1663248072/indiependente.dev/k8srequestslimits/podspecprop.png></p><ol><li>Pod spec is registered in <strong>etcd</strong> through the <strong>kube-apiserver</strong></li><li><strong>kube-scheduler</strong> fetches newly registered pods from etcd and assigns a node to each pod referring to resource requests</li><li><strong>kubelet</strong> fetches assigned pod spec in every sync period and calculates the differences between running containers and pod spec</li><li><strong>kubelet</strong> calls CreateContainer operation on the <strong>CRI Runtime</strong>, after converting CPU cores into periods</li><li><strong>CRI Runtime</strong> executes <strong>OCI Runtime</strong> binary to create a container with OCI Spec JSON</li><li><strong>OCI Runtime</strong> creates/updates/deletes <strong>cgroups</strong> accordingly</li></ol><h3 id=2-qos-classes>2. QoS Classes<a hidden class=anchor aria-hidden=true href=#2-qos-classes>#</a></h3><p>When Kubernetes creates a Pod, it assigns one of the following QoS classes depending on the condition</p><table><thead><tr><th style=text-align:center>QoS Class</th><th style=text-align:center>Condition</th><th style=text-align:center>Priority (lower is better)</th></tr></thead><tbody><tr><td style=text-align:center>Guaranteed</td><td style=text-align:center>Limits and optionally requests (not equal to 0) are set for all resources across all containers and they are equal</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>Burstable</td><td style=text-align:center>Requests and optionally limits are set (not equal to 0) for one or more resources across one or more containers, and they are not equal</td><td style=text-align:center>2</td></tr><tr><td style=text-align:center>Best Effort</td><td style=text-align:center>Requests and limits are not set for all of the resources, across all containers</td><td style=text-align:center>3</td></tr></tbody></table><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ol><li><a href=https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>Resource Management for Pods and Containers</a></li><li><a href=https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource/>Assign CPU Resources to Containers and Pods</a></li><li><a href=https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/>Assign Memory Resources to Containers and Pods</a></li><li><a href=https://kubernetes.io/docs/concepts/architecture/cri/>Container Runtime Interface (CRI)</a></li><li><a href=https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/>Configure Quality of Service for Pods</a></li><li><a href=https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt>CFS Scheduler on kernel.org</a></li><li><a href=https://home.robusta.dev/blog/stop-using-cpu-limits/>For the love of God, stop using CPU limits on Kubernetes</a></li><li><a href=https://erickhun.com/posts/kubernetes-faster-services-no-cpu-limits/>Kubernetes: Make your services faster by removing CPU limits</a></li><li><a href=https://k8s.af/>Kubernetes failure stories</a></li><li><a href="https://news.ycombinator.com/item?id=24351566">HN conversation about removing CPU Limits</a></li><li><a href=https://engineering.indeedblog.com/blog/2019/12/unthrottled-fixing-cpu-limits-in-the-cloud/>CPU Throttling - Unthrottled: Fixing CPU limits in the Cloud</a></li><li><a href="https://www.youtube.com/watch?v=UE7QX98-kO0">Throttling: New Developments in Application Performance with CPU Limits - Dave Chiluk, Indeed</a></li><li><a href="https://www.youtube.com/watch?v=WB3_sV_EQrQ">Resource Requests and Limits Under the Hood: The Journey of a Pod Spec - Kohei Ota & Kaslin Fields</a></li><li><a href="https://www.youtube.com/watch?v=4CT0cI62YHk">10 More Weird Ways to Blow Up Your Kubernetes - Jian Cheung & Joseph Kim, Airbnb</a></li><li><a href="https://www.youtube.com/watch?v=QXApVwRBeys">Did Kubernetes Make My p95s Worse? - Jian Cheung & Stephen Chan, Airbnb</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://indiependente.dev/tags/kubernetes/>Kubernetes</a></li><li><a href=https://indiependente.dev/tags/requests/>Requests</a></li><li><a href=https://indiependente.dev/tags/limits/>Limits</a></li><li><a href=https://indiependente.dev/tags/cpu/>Cpu</a></li><li><a href=https://indiependente.dev/tags/memory/>Memory</a></li><li><a href=https://indiependente.dev/tags/pods/>Pods</a></li><li><a href=https://indiependente.dev/tags/containers/>Containers</a></li><li><a href=https://indiependente.dev/tags/performance/>Performance</a></li><li><a href=https://indiependente.dev/tags/cfs/>Cfs</a></li><li><a href=https://indiependente.dev/tags/cgroups/>Cgroups</a></li></ul><nav class=paginav><a class=prev href=https://indiependente.dev/posts/2024/08/santorini-my-tips-after-one-week/><span class=title>« Prev</span><br><span>🇬🇷 Santorini: my tips after one week</span>
</a><a class=next href=https://indiependente.dev/posts/2021/03/%C6%9B-aws-lambdas-containers-and-go/><span class=title>Next »</span><br><span>ƛ📦 AWS Lambdas containers and Go</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes Requests & Limits on x" href="https://x.com/intent/tweet/?text=Kubernetes%20Requests%20%26%20Limits&amp;url=https%3a%2f%2findiependente.dev%2fposts%2f2022%2f09%2fkubernetes-requests-limits%2f&amp;hashtags=kubernetes%2crequests%2climits%2ccpu%2cmemory%2cpods%2ccontainers%2cperformance%2ccfs%2ccgroups"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes Requests & Limits on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2findiependente.dev%2fposts%2f2022%2f09%2fkubernetes-requests-limits%2f&amp;title=Kubernetes%20Requests%20%26%20Limits&amp;summary=Kubernetes%20Requests%20%26%20Limits&amp;source=https%3a%2f%2findiependente.dev%2fposts%2f2022%2f09%2fkubernetes-requests-limits%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes Requests & Limits on reddit" href="https://reddit.com/submit?url=https%3a%2f%2findiependente.dev%2fposts%2f2022%2f09%2fkubernetes-requests-limits%2f&title=Kubernetes%20Requests%20%26%20Limits"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes Requests & Limits on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2findiependente.dev%2fposts%2f2022%2f09%2fkubernetes-requests-limits%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes Requests & Limits on whatsapp" href="https://api.whatsapp.com/send?text=Kubernetes%20Requests%20%26%20Limits%20-%20https%3a%2f%2findiependente.dev%2fposts%2f2022%2f09%2fkubernetes-requests-limits%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes Requests & Limits on telegram" href="https://telegram.me/share/url?text=Kubernetes%20Requests%20%26%20Limits&amp;url=https%3a%2f%2findiependente.dev%2fposts%2f2022%2f09%2fkubernetes-requests-limits%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes Requests & Limits on ycombinator" href="https://news.ycombinator.com/submitlink?t=Kubernetes%20Requests%20%26%20Limits&u=https%3a%2f%2findiependente.dev%2fposts%2f2022%2f09%2fkubernetes-requests-limits%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://indiependente.dev/>Francesco Farina</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>